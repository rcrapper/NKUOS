# lab0.5

## 练习1：使用GDB验证启动流程

### 为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。

在RISC-V硬件加电后的几条指令通常是引导程序(Bootloader) 执行的指令。这些指令的目标是初始化硬件和加载操作系统或应用程序。具体来说，以下是RISC-V硬件加电后的几条指令的典型执行过程:

1. **复位向量(Reset Vector)**：当RISC-V处理器加电时，它会从预定义的复位向量地址开始执行指令。在RISC-V中，复位向量通常是0x80000000
2. **初始化指令**:在复位向量地址处，通常会有一些初始化指令，用于设置处理器的初始状态。这些指令可能包括设置栈指针、设置异常处理程序等。
3. **加载引导程序**:接下来，引导程序会被加载到内存中。引导程序是一个小型的软件程序，负责初始化硬件设备加载操作系统或应用程序，并将控制权转移到它们。
4. **初始化硬件设备**:引导程序可能会初始化与硬件设备相关的寄存器、中断控制器、时钟等。这些初始化操作确保硬件设备处于正确的状态，以便后续的操作系统或应用程序可以正常运行。
5. **加载操作系统或应用程序**:引导程序会从存储介质(如磁盘或闪存)中加载操作系统或应用程序的映像文件。这通常涉及读取文件系统、解析文件格式，并将映像文件加载到内存中的适当位置。
6. **跳转到应用程序入口点**:一旦操作系统或应用程序被加载到内存中，引导程序会将控制权转移到操作系统或应用程序的入口点。这个入口点是操作系统或应用程序的第一条指令的地址，通常是0x80200000。

总结起来，RISC-V硬件加电后的几条指今主要完成了以下功能，初始化处理器状态、初始化硬件设备、加载引导程序、加载操作系统或应用程序，并将控制权转移到操作系统或应用程序的入口点。这些步骤确保了系统的正确启动.

### gdb指令

![](https://ooo.0x0.ooo/2023/10/07/O1vYRt.png)

![](https://pic.imgdb.cn/item/6520f9eec458853aef28a622.png)

![](https://pic.imgdb.cn/item/6520f94ec458853aef28600b.png)

![](https://pic.imgdb.cn/item/6520f9eec458853aef28a639.png)

# lab1

## 练习1：理解内核启动中的程序入口操作

### 阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

![](https://pic.imgdb.cn/item/6520fb2fc458853aef29979d.png)

指令 la sp, bootstacktop 完成了将 bootstacktop 的地址加载到寄存器 sp （栈指针）中的操作。它的目的是设置内核栈的顶部位置。

在操作系统内核启动时，需要为内核代码和数据分配一块私有的栈空间。栈用于保存函数调用时的局部变量、函数返回地址等临时信息。bootstack 和 bootstacktop 是内核栈的起始和结束地址，在 entry.S 中定义。通过将 bootstacktop 的地址加载到 sp 寄存器中，将栈顶指针初始化为内核栈的顶部，从而指示栈从高地址向低地址增长。

tail kern_init 是一个尾调用指令，将控制权传递给 kern_init 函数。kern_init 是内核的初始化入口点，它负责完成操作系统的初始化工作，包括初始化硬件、建立内存映射、初始化设备驱动、创建进程等。通过使用尾调用指令，可以使 kern_init 成为首个运行的函数，并且不会在调用栈上保留 kern_entry 的返回地址，从而节省了栈空间。

因此，上述代码片段的目的是设置内核栈的顶部，并通过尾调用指令跳转到内核初始化函数，实现操作系统内核的启动。

## 练习2：完善中断处理 

### 请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。

### 要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。

![](https://pic.imgdb.cn/item/6520fbaec458853aef29fdfb.png)

## 扩展练习 Challenge1：描述与理解中断流程

### 回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。

1. **异常的产生**：异常通常由外部事件（例如时钟中断、硬件错误等）或指令执行（例如非法操作码、除零错误等）引发，CPU会暂停当前执行的程序，跳转到中断处理的函数。
2. **保存所有寄存器**：将所有的寄存器保存到栈中，包括程序的返回值、程序计数器、基指针等。
3. **进入异常处理程序**：跳转到预先定义好的异常处理程序的入口点，进行异常类型的判断和处理。
4. **恢复寄存器并返回**：处理完中断后，会从栈中恢复所有的寄存器，然后返回到被中断的程序。

`mov a0, sp`的目的是将栈指针sp的值保存到a0寄存器中，这是为了在后续的异常处理中可以方便地访问栈的内容，以便恢复寄存器状态和执行其他操作。

在`SAVE_ALL`中，寄存器保存在栈中的位置是通过栈指针 sp 和偏移量得出，栈顶的地址是最低的，a0寄存器用来指向栈顶。

`__alltraps`需要保存所有寄存器。因为中断可能在任何时刻发生，所以CPU必须保存所有寄存器的状态以便能正确的返回到被中断的程序。如果不保存所有寄存器的状态，那么返回到被中断的程序时，程序可能会因为寄存器状态的不正确而产生错误。

## 扩增练习 Challenge2：理解上下文切换机制
### 回答：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？
在汇编代码 `csrw sscratch, sp` 中，`csrw` 指令用于将当前的栈指针寄存器 `sp` 的值保存到 `sscratch` 控制状态寄存器（CSR）中。这个操作的目的是将当前栈指针 `sp` 的值保存到 `sscratch` 中，以便在后续的异常处理过程中可以使用 `sscratch` 来保存和恢复 `sp` 的值，以确保在异常处理期间不会丢失栈的信息。

关于为什么在 `save all` 中保存了一些CSR寄存器（如 `stval`、`scause`）而在 `restore all` 中不还原它们，这涉及到异常处理的流程和需求。这些CSR寄存器通常用于保存关于异常或中断的信息，以便后续的处理程序能够了解异常的原因和上下文。在 `save all` 阶段，保存这些寄存器是为了将异常的上下文信息保存在内核栈中，以备后续的异常处理程序需要使用。

然而，在 `restore all` 阶段，通常不需要还原这些CSR寄存器的值，因为异常处理程序已经在 `save all` 阶段保存了它们的值，如果需要使用这些值，可以直接从内核栈中获取。而在 `restore all` 阶段，更重要的是恢复通用寄存器的状态以及栈指针 `sp` 的值，以确保程序可以正确返回到异常点之后的执行。因此，不还原这些CSR寄存器的值是为了减少不必要的开销和复杂性。

总之，`save all` 阶段保存CSR寄存器的值是为了备份异常上下文信息，而在 `restore all` 阶段通常不需要还原它们，因为它们可以在需要时从内核栈中获取。这样的设计可以简化异常处理的流程并提高效率。

## 扩展练习Challenge3：完善异常中断

### 编程完善在触发一条非法指令异常 mret和，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。

![](https://pic.imgdb.cn/item/6520fcdec458853aef2ab5e4.jpg)

并在中断处理函数trap中shutdown前添加代码` __asm__("mret");`,实现非法指令异常，运行后结果如下图：

![](https://pic.imgdb.cn/item/6521018bc458853aef2e283a.jpg)

